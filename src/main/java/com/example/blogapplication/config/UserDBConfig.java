package com.example.blogapplication.config;

import jakarta.persistence.EntityManagerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.jdbc.DataSourceBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import javax.sql.DataSource;
import java.util.HashMap;

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
        entityManagerFactoryRef = "userEntityManagerFactory",
        transactionManagerRef = "userTransactionManager",
        basePackages = {
                "com.example.blogapplication.db1.repositories" // ‚úÖ Fixed package format
        }
)
public class UserDBConfig {


//    What Does @ConfigurationProperties(prefix = "spring.user.datasource") Do?
//            ‚úîÔ∏è Binds external configuration properties (from application.properties or application.yml) to this method.
//‚úîÔ∏è The prefix spring.user.datasource tells Spring Boot to look for database properties that start with this prefix.
//
//üîπ Example application.properties or application.yml:
//
//    properties
//            Copy
//    Edit
//    spring.user.datasource.url=jdbc:mysql://localhost:3306/userdb
//    spring.user.datasource.username=root
//    spring.user.datasource.password=yourpassword
//    spring.user.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
//    spring.user.datasource.hikari.maximum-pool-size=10
//            üîπ What Happens? ‚úÖ Spring Boot automatically reads these properties.
//            ‚úÖ It injects these values into DataSourceBuilder.create().build().
//            ‚úÖ A DataSource object is created with this database configuration.
//            ‚úÖ This DataSource is used for all database operations related to the User Database.
//

    @Primary
    @Bean(name = "userDataSource")  // ‚úÖ Renamed from "dataSource" to avoid conflicts
    @ConfigurationProperties(prefix = "spring.user.datasource")

    public DataSource userDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean(name = "userEntityManagerFactory")  // ‚úÖ Renamed to match entityManagerFactoryRef
    public LocalContainerEntityManagerFactoryBean userEntityManagerFactory(
            @Qualifier("userDataSource") DataSource dataSource) {  // ‚úÖ Updated reference to new name

        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan("com.example.blogapplication.db1.entities"); // ‚úÖ Fixed package format
        em.setPersistenceUnitName("User");

        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
        em.setJpaVendorAdapter(vendorAdapter);

        HashMap<String, Object> properties = new HashMap<>();

        properties.put("hibernate.dialect", "org.hibernate.dialect.MySQL8Dialect");
        properties.put("hibernate.hbm2ddl.auto", "update");


        em.setJpaPropertyMap(properties);

        return em;
    }

//    What is @Qualifier and How Does It Work?
//            üîπ In Spring Boot, if you have multiple beans of the same type, Spring doesn‚Äôt know which one to use.
//            üîπ @Qualifier helps Spring identify the correct bean by name.
//
//            üîπ Example Without @Qualifier (Causes Ambiguity)
//
//    java
//            Copy
//    Edit
//    @Bean
//    public DataSource userDataSource() {
//        return DataSourceBuilder.create().build();
//    }
//
//    @Bean
//    public DataSource blogDataSource() {
//        return DataSourceBuilder.create().build();
//    }
//
//    @Bean
//    public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
//        // ERROR: Spring doesn't know which DataSource to use (UserDB or BlogDB)
//    }
//üîπ Solution Using @Qualifier
//
//    java
//            Copy
//    Edit
//    @Bean
//    public LocalContainerEntityManagerFactoryBean entityManagerFactory(
//            @Qualifier("userDataSource") DataSource dataSource) {
//        // Now Spring knows to use the "userDataSource" for this entity manager.
//    }
//‚úîÔ∏è @Qualifier("userDataSource") ensures that the correct DataSource is injected.
//‚úîÔ∏è Prevents conflicts in multi-database configurations.
//




    @Primary
    @Bean(name = "userTransactionManager")  // ‚úÖ Renamed to match transactionManagerRef
    public PlatformTransactionManager userTransactionManager(
            @Qualifier("userEntityManagerFactory") EntityManagerFactory userEntityManagerFactory) { // ‚úÖ Updated reference
        return new JpaTransactionManager(userEntityManagerFactory);
    }
}














//Yes! Let me explain what each part of your **UserDBConfig** is doing and how it works in your **Spring Boot multi-database JPA setup**.
//
//        ---
//
//        ## **üîπ What Does This Configuration Do?**
//        This configuration **sets up a separate database connection** for handling **User-related data** in your application.
//
//        üîπ It **defines a separate data source**, an **EntityManagerFactory**, and a **TransactionManager** for the **User Database (DB1)**.
//        üîπ Since this is the **primary** database, we mark it with `@Primary` to tell Spring that it should be used **by default** unless specified otherwise.
//
//        ---
//
//        ## **1Ô∏è‚É£ `@Configuration` & `@EnableTransactionManagement`**
//        ```java
//@Configuration
//@EnableTransactionManagement
//```
//        ‚úîÔ∏è `@Configuration` ‚Üí Marks this class as a Spring **configuration** class (meaning it provides beans).
//        ‚úîÔ∏è `@EnableTransactionManagement` ‚Üí Enables **Spring‚Äôs transaction management**, allowing you to use `@Transactional` for managing database transactions.
//
//        ---
//
//        ## **2Ô∏è‚É£ `@EnableJpaRepositories` ‚Äì Configuring JPA Repositories**
//        ```java
//@EnableJpaRepositories(
//        entityManagerFactoryRef = "userEntityManagerFactory",
//        transactionManagerRef = "userTransactionManager",
//        basePackages = {
//                "com.example.blogapplication.db1.repositories"
//        }
//)
//```
//        This **tells Spring Boot** where to find **the JPA repositories** for the User database and which **EntityManagerFactory & TransactionManager** to use.
//
//        ‚úîÔ∏è **`entityManagerFactoryRef = "userEntityManagerFactory"`**
//        ‚Üí Specifies that this repository should use the **userEntityManagerFactory** (which we define later).
//
//        ‚úîÔ∏è **`transactionManagerRef = "userTransactionManager"`**
//        ‚Üí Specifies that transactions in this repository should be managed by **userTransactionManager**.
//
//        ‚úîÔ∏è **`basePackages = "com.example.blogapplication.db1.repositories"`**
//        ‚Üí Specifies where **Spring Data JPA** should scan for **repository interfaces** related to the **User database**.
//
//        ---
//
//        ## **3Ô∏è‚É£ Defining the Data Source (Database Connection)**
//        ```java
//@Primary
//@Bean(name = "userDataSource")
//@ConfigurationProperties(prefix = "spring.user.datasource")
//public DataSource userDataSource() {
//        return DataSourceBuilder.create().build();
//        }
//        ```
//        This **configures the User database connection** using properties from `application.properties` or `application.yml`.
//
//        ‚úîÔ∏è **`@Primary`**
//        ‚Üí Marks this data source as the **default one**, so Spring uses it **unless another one is explicitly requested**.
//
//        ‚úîÔ∏è **`@Bean(name = "userDataSource")`**
//        ‚Üí Registers this **bean** in Spring's application context under the name **`userDataSource`**.
//
//        ‚úîÔ∏è **`@ConfigurationProperties(prefix = "spring.user.datasource")`**
//        ‚Üí Loads **database connection properties** from `application.properties` or `application.yml`, such as:
//        ```properties
//        spring.user.datasource.url=jdbc:mysql://localhost:3306/userdb
//        spring.user.datasource.username=root
//        spring.user.datasource.password=yourpassword
//        spring.user.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
//        ```
//        ---
//
//        ## **4Ô∏è‚É£ Defining the EntityManagerFactory (JPA Entity Manager)**
//        ```java
//@Primary
//@Bean(name = "userEntityManagerFactory")
//public LocalContainerEntityManagerFactoryBean userEntityManagerFactory(
//@Qualifier("userDataSource") DataSource dataSource) {
//
//        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
//        em.setDataSource(dataSource);
//        em.setPackagesToScan("com.example.blogapplication.db1.entities");
//        em.setPersistenceUnitName("User");
//
//        HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
//        em.setJpaVendorAdapter(vendorAdapter);
//
//        HashMap<String, Object> properties = new HashMap<>();
//        properties.put("hibernate.hbm2ddl.auto", "update");
//
//        em.setJpaPropertyMap(properties);
//
//        return em;
//        }
//        ```
//        This **creates an `EntityManagerFactory`** for interacting with **User Database Entities**.
//
//        ‚úîÔ∏è **`@Primary`** ‚Üí Marks this `EntityManagerFactory` as the default one.
//
//        ‚úîÔ∏è **`@Bean(name = "userEntityManagerFactory")`**
//        ‚Üí Creates a `LocalContainerEntityManagerFactoryBean` named **userEntityManagerFactory**.
//
//        ‚úîÔ∏è **`@Qualifier("userDataSource") DataSource dataSource`**
//        ‚Üí Tells Spring to use the `userDataSource` bean (the User Database).
//
//        ‚úîÔ∏è **`em.setPackagesToScan("com.example.blogapplication.db1.entities")`**
//        ‚Üí Tells Hibernate to look for **JPA entity classes** in this package.
//
//        ‚úîÔ∏è **`em.setPersistenceUnitName("User")`**
//        ‚Üí This name is **used internally by JPA** to differentiate between multiple databases.
//
//        ‚úîÔ∏è **`em.setJpaVendorAdapter(new HibernateJpaVendorAdapter())`**
//        ‚Üí Configures **Hibernate** as the JPA provider.
//
//        ‚úîÔ∏è **Sets Hibernate Properties:**
//        ```java
//        properties.put("hibernate.hbm2ddl.auto", "update");
//        ```
//        ‚Üí This ensures that the **database schema updates automatically** when the app starts.
//        *(Other options: `create`, `validate`, `none`)*
//
//        ---
//
//        ## **5Ô∏è‚É£ Defining the Transaction Manager**
//        ```java
//@Primary
//@Bean(name = "userTransactionManager")
//public PlatformTransactionManager userTransactionManager(
//@Qualifier("userEntityManagerFactory") EntityManagerFactory userEntityManagerFactory) {
//        return new JpaTransactionManager(userEntityManagerFactory);
//        }
//        ```
//        ‚úîÔ∏è **This ensures that all User Database operations are managed inside transactions.**
//        ‚úîÔ∏è **`@Qualifier("userEntityManagerFactory")`**
//        ‚Üí Ensures that this transaction manager uses the **correct database connection**.
//        ‚úîÔ∏è **`new JpaTransactionManager(userEntityManagerFactory)`**
//        ‚Üí Uses **Spring's Transaction Manager** to **manage transactions for the User database**.
//
//        ---
//
//        ## **üöÄ How This Works Together**
//        1Ô∏è‚É£ **Spring Boot reads `application.properties` and sets up the User Database (`userDataSource`).**
//        2Ô∏è‚É£ **Creates an `EntityManagerFactory` for User DB using Hibernate.**
//        3Ô∏è‚É£ **Scans for JPA entities in `com.example.blogapplication.db1.entities`.**
//        4Ô∏è‚É£ **Scans for repositories in `com.example.blogapplication.db1.repositories`.**
//        5Ô∏è‚É£ **Sets up a Transaction Manager (`userTransactionManager`) to handle database transactions.**
//
//        ---
//
//        ## **üîπ How Does This Work with Multiple Databases?**
//        üîπ You now have **two separate database configurations**:
//        ‚úîÔ∏è **`UserDBConfig`** ‚Üí Handles the **User Database** (`DB1`).
//        ‚úîÔ∏è **`BlogDBConfig`** ‚Üí Handles the **Blog Database** (`DB2`).
//
//        Both databases **have their own `DataSource`, `EntityManagerFactory`, and `TransactionManager`**, ensuring that data **doesn‚Äôt mix between databases**.
//
//        ---
//
//        ## **üéØ Final Summary**
//        | Component                     | Purpose |
//        |--------------------------------|---------|
//        | `@EnableJpaRepositories`       | Scans for User DB repositories |
//        | `userDataSource`               | Configures the User Database connection |
//        | `userEntityManagerFactory`     | Manages JPA entities for the User DB |
//        | `userTransactionManager`       | Handles transactions for User DB |
//
//        ---
//
//        ## **üöÄ Conclusion**
//        ‚úÖ This configuration ensures that **Spring Boot can connect to and manage the User Database independently**.
//        ‚úÖ It allows you to **use multiple databases in the same application** without conflicts.
//        ‚úÖ Your **repositories, entities, and transactions** will work correctly with the User Database (`DB1`).
//
//        With these **User & Blog DB Configurations**, your **multi-database setup is complete!** üéâ